// Generated by CoffeeScript 1.4.0
(function() {
  var Sketch, abs, dist, max, min, pow, print, sqr, sqrt, sum, _ref,
    __slice = [].slice;

  abs = function(n) {
    return Math.abs(n);
  };

  min = function() {
    var n;
    n = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return Math.min.apply(Math, n);
  };

  max = function() {
    var n;
    n = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return Math.max.apply(Math, n);
  };

  pow = function(n, p) {
    return Math.pow(n, p);
  };

  sqr = function(n) {
    return Math.pow(n, 2);
  };

  sqrt = function(n) {
    return Math.sqrt(n);
  };

  sum = function(o) {
    if (o.length) {
      return o.reduce(function(a, b) {
        return a + b;
      });
    } else {
      return "";
    }
  };

  dist = function(a, b) {
    var ai, i;
    return sqrt(sum((function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
        ai = a[i];
        _results.push(sqr(ai - (b ? b[i] : 0)));
      }
      return _results;
    })()));
  };

  print = function(o) {
    return console.log(o);
  };

  this.showgrad = {
    checked: false
  };

  this.showforce = {
    checked: true
  };

  this.showzero = {
    checked: true
  };

  this.move = {
    checked: false
  };

  Sketch = (function() {

    function Sketch(htmlLoc, structure, height, width) {
      var d, draw, htmlObj, htmlRect, list, maxs, means, mins, mousedn, n, translate, zoomer, _i, _len, _ref, _ref1,
        _this = this;
      if (htmlLoc == null) {
        htmlLoc = "body";
      }
      htmlObj = d3.select(htmlLoc);
      if (structure != null) {
        this.structure = structure;
      } else {
        this.structure = new tacit.Structure;
      }
      htmlRect = htmlObj.node().getBoundingClientRect();
      if (width == null) {
        width = htmlRect.width;
      }
      if (height == null) {
        height = htmlRect.height;
      }
      this.svg = htmlObj.append("svg:svg").attr("width", width).attr("height", height).attr("pointer-events", "all");
      this.scale = 1;
      zoomer = d3.behavior.zoom().on("zoom", function() {
        return _this.rescale();
      });
      mousedn = function() {
        return _this.pad.call(d3.behavior.zoom().on("zoom"), function() {
          return _this.rescale();
        });
      };
      this.selected_node = this.selected_link = null;
      this.pad = this.svg.append("svg:g").attr("transform", "translate(0," + height + ") scale(1,-1)").append("svg:g").call(zoomer).on("dblclick.zoom", null).append("svg:g").on("mousedown", mousedn);
      this.pad.append("svg:rect").attr("x", -width / 2).attr("y", -height / 2).attr("width", width).attr("height", height).attr("fill", "transparent");
      this.nodes = this.pad.selectAll(".node");
      this.links = this.pad.selectAll(".link");
      this.forces = this.pad.selectAll(".force");
      this.grads = this.pad.selectAll(".grad");
      this.dragline = this.pad.append("line").attr("class", "dragline").attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
      if (structure != null) {
        _ref = [{}, {}, {}], mins = _ref[0], maxs = _ref[1], means = _ref[2];
        _ref1 = ["x", "y", "z"];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          d = _ref1[_i];
          list = (function() {
            var _j, _len1, _ref2, _results;
            _ref2 = structure.nodeList;
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              n = _ref2[_j];
              _results.push(n[d]);
            }
            return _results;
          })();
          mins[d] = min.apply(null, list);
          maxs[d] = max.apply(null, list);
          means[d] = sum(list) / structure.nodeList.length;
        }
        this.scale = 0.5 * min(width / (maxs.x - mins.x), height / (maxs.y - mins.y));
        translate = [this.scale * means.x, height / 2 - this.scale * means.y];
        zoomer.scale(this.scale);
        zoomer.translate(translate);
        this.rescale(translate, this.scale, draw = false);
      }
    }

    Sketch.prototype.rescale = function(translate, scale, draw) {
      if (draw == null) {
        draw = true;
      }
      if (translate == null) {
        translate = d3.event.translate;
      }
      if (scale == null) {
        scale = d3.event.scale;
      }
      this.scale = scale;
      this.pad.attr("transform", "translate(" + translate + ") scale(" + scale + ")");
      if (draw) {
        return this.resize();
      }
    };

    Sketch.prototype.update = function() {
      var _this = this;
      this.links = this.links.data(this.structure.beamList);
      this.links.enter().insert("line", ".node").attr("class", "link");
      this.links.exit().remove();
      this.links.classed("selected", function(d) {
        return d === _this.selected_link;
      });
      this.forces = this.forces.data(this.structure.nodeList);
      this.forces.enter().insert("line").attr("class", "force").attr("stroke-width", 0).attr("marker-end", "url(#brtriangle)");
      this.forces.exit().remove();
      this.grads = this.grads.data(this.structure.nodeList);
      this.grads.enter().insert("line").attr("class", "grad").attr("stroke-width", 0).attr("marker-end", "url(#ptriangle)");
      this.grads.exit().remove();
      this.nodes = this.nodes.data(this.structure.nodeList);
      this.nodes.enter().insert("circle").attr("class", "node").attr("r", 5 / this.scale).transition().duration(750).ease("elastic").attr("r", 9 / this.scale);
      this.nodes.exit().transition().attr("r", 0).remove();
      this.nodes.classed("node_selected", function(d) {
        return d === _this.selected_node;
      });
      return this.redraw();
    };

    Sketch.prototype.redraw = function() {
      var w,
        _this = this;
      this.structure.solve();
      w = this.structure.nodeList.length / this.structure.lp.obj;
      this.dragline.attr("stroke-width", 10 / this.scale).attr("stroke-dasharray", 10 / this.scale + "," + 10 / this.scale);
      this.links.attr("x1", function(d) {
        return d.source.x;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("y2", function(d) {
        return d.target.y;
      }).attr("stroke-dasharray", function(d) {
        if (d.F) {
          return null;
        } else {
          return 10 / _this.scale + "," + 10 / _this.scale;
        }
      }).classed("compression", function(d) {
        return d.f < 0;
      }).classed("tension", function(d) {
        return d.f > 0;
      }).transition().duration(750).ease("elastic").attr("stroke-width", function(d) {
        return 0.035 * d.F || 5 / _this.scale * showzero.checked;
      });
      this.nodes.attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).transition().duration(750).ease("elastic").attr("r", function(d) {
        return 18 / _this.scale * (d === _this.selected_node ? 2 : 1);
      });
      this.forces.attr("x1", function(d) {
        return d.x;
      }).attr("x2", function(d) {
        return d.x + d.force.x / 4;
      }).attr("y1", function(d) {
        return d.y;
      }).attr("y2", function(d) {
        return d.y + d.force.y / 4;
      }).attr("stroke-width", function(d) {
        var f;
        if (dist((function() {
          var _ref, _results;
          _ref = d.force;
          _results = [];
          for (d in _ref) {
            f = _ref[d];
            _results.push(f);
          }
          return _results;
        })()) > 0) {
          return 10 / _this.scale * showforce.checked;
        } else {
          return 0;
        }
      });
      return this.grads.attr("x1", function(d) {
        return d.x;
      }).attr("x2", function(d) {
        return d.x - 50 / _this.scale * d.grad.x * w;
      }).attr("y1", function(d) {
        return d.y;
      }).attr("y2", function(d) {
        return d.y - 50 / _this.scale * d.grad.y * w;
      }).attr("stroke-width", function(d) {
        var l;
        if (50 / _this.scale * dist((function() {
          var _ref, _results;
          _ref = d.grad;
          _results = [];
          for (d in _ref) {
            l = _ref[d];
            _results.push(l);
          }
          return _results;
        })()) * w > 0.05) {
          return 10 / _this.scale * showgrad.checked;
        } else {
          return 0;
        }
      });
    };

    return Sketch;

  })();

  ({
    reposition: function() {
      var w,
        _this = this;
      this.structure.solve();
      this.resize();
      w = this.structure.nodeList.length / this.structure.lp.obj;
      this.dragline.attr("stroke-width", 10 / this.scale).attr("stroke-dasharray", 10 / this.scale + "," + 10 / this.scale);
      this.links.attr("x1", function(d) {
        return d.source.x;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("y2", function(d) {
        return d.target.y;
      }).classed("compression", function(d) {
        return d.f < 0;
      }).classed("tension", function(d) {
        return d.f > 0;
      });
      this.nodes.attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
      this.forces.attr("x1", function(d) {
        return d.x;
      }).attr("x2", function(d) {
        return d.x + d.force.x / 4;
      }).attr("y1", function(d) {
        return d.y;
      }).attr("y2", function(d) {
        return d.y + d.force.y / 4;
      });
      return this.grads.attr("x1", function(d) {
        return d.x;
      }).attr("x2", function(d) {
        return d.x - 50 / _this.scale * d.grad.x * w;
      }).attr("y1", function(d) {
        return d.y;
      }).attr("y2", function(d) {
        return d.y - 50 / _this.scale * d.grad.y * w;
      });
    },
    resize: function() {
      var w,
        _this = this;
      w = this.structure.nodeList.length / this.structure.lp.obj;
      this.links.attr("stroke-dasharray", function(d) {
        if (d.F) {
          return null;
        } else {
          return 10 / _this.scale + "," + 10 / _this.scale;
        }
      }).attr("stroke-width", function(d) {
        return 0.035 * d.F || 5 / _this.scale * showzero.checked;
      });
      this.nodes.attr("r", function(d) {
        return 18 / _this.scale * (d === _this.selected_node ? 2 : 1);
      });
      this.forces.attr("stroke-width", function(d) {
        var f;
        if (dist((function() {
          var _ref, _results;
          _ref = d.force;
          _results = [];
          for (d in _ref) {
            f = _ref[d];
            _results.push(f);
          }
          return _results;
        })()) > 0) {
          return 10 / _this.scale * showforce.checked;
        } else {
          return 0;
        }
      });
      return this.grads.attr("stroke-width", function(d) {
        var l;
        if (50 / _this.scale * dist((function() {
          var _ref, _results;
          _ref = d.grad;
          _results = [];
          for (d in _ref) {
            l = _ref[d];
            _results.push(l);
          }
          return _results;
        })()) * w > 0.05) {
          return 10 / _this.scale * showgrad.checked;
        } else {
          return 0;
        }
      });
    }
  });

  if ((_ref = this.tacit) == null) {
    this.tacit = {};
  }

  this.tacit.Sketch = Sketch;

}).call(this);
